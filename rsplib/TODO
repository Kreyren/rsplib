result = rsp_recvmsg()

result == 0: Session-Ende, kein FO möglich
result == -1, errno = EAGAIN (o.ä.) -> FO möglich/kein Fehler, etc.
result >0: Data/Notif./Cookie


--------

Msg-Queue:
- Verhalten bei PR-Ausfall
- Statische PRs


--------


RSerPool-API:


Rückgabewerte für rsp_write() / rsp_read():
  Notifications!!!!!

  RSPERR_FAILOVER_NECESSARY
    Nächster Aufruf wird Failover durchführen
    Prüfung, ob Cookie vorhanden: rsp_has_cookie(...)
  RSPERR_IO_TIMEOUT:
    Timeout ist aufgetreten, ggf. manueller Failover notwendig


 Rückgabe bei Failover:
   mit Cookie:
     Fehler RSPERR_AUTO_FAILOVER
   ohne Cookie:
     Fehler RSPERR_MANUAL_FAILOVER


NOSR
NOPKG
MSG_NOSIGNAL

------

PingPong Protocol:

Ping {
   MessageNo;
   Data[];
}

Pong {
   MessageNo;
   ReplyNo
   Data[];
}


------

Last für ThreadedServer:
  Je Thread: weight, load e(0%,100%)
     => Gesamt-Last: gewichtete Load-Summe / Gewicht-Summe

   Threaded-Server (PE-sd, Session-ID)
     => setLoad() -> Berechnung über List -> Update???
   oder ext. Fkt.  updateLoad()
      static FractalGenerator::updateLoad()

------

Notifications treten auf bei:
 read oder write
 -> nicht innerhalb Wartefunktion mit rsp_select()!


=================

TCP-Like:
 Server:
   PE -> ein Accept-Socket
   jede Session: eigenes RSerPool-Socket
 Client:
   Session -> eigenes Socket

UDP-Like:
 Server:
   PE -> ein UDP-like Socket
   write() -> Mit Session-ID bzw. PH -> ok.
   read()  -> Aggregat über mehrere Sessions
      -> Session-ID wird mit gelesen.

 Client:
   write() -> Mit Session-ID bzw. PH -> ok.
   read()  -> Aggregat über mehrere Sessions
      -> Session-ID wird mit gelesen.
      Ist das sinnvoll???

-----

Failover mit UDP-like Socket:
  =====
  RSerPoolSocket: Kommunikationsbeziehung
   PU: eine einzige Session
   PE: viele - eingehende - Sessions
  =====
  - Je RSerPool-Socket:
       Remote-PH
    Session besitzt keinen PH (das hat nur das Socket)!!!!
  PU: Es gibt nur *eine* Session!
      CommLost
      -> Session->AssocID = 0; merken, daß im Failover-Zustand
      -> connect() ...
      -> CommUp
      -> Failover-Zustand -> Session->AssocID = newAssocID
      -> Failover-Prozedur.
      OK.
  PE: Es gibt viele Sessions (eingehende)
     CommLost
     -> Session entfernen
     CommUp
     -> Session hinzufügen
     -> Cookie annehmen
     OK.

     symmetrischer Fall:
     -------------------
     PE.Session macht Peel-Off für neue Sessions
     Bei Ausfall muß dann Socket durch UDP-like ersetzt werden.


=================


oberhalb von rsp_read() / rsp_write(), z.B. l5_read() / l5_write() ...
- z.B. PPID = 55555555
- Multi-Streaming???????

L5DATA:
SeqNumber
AckNumber
Data
 ...

L5ACK:
AckNumber
Cookie (opt.)       !!!!!!!!!!!!!!!
 ...


l5d=l5_init(session, istreams, ostreams)
l5msg = l5_read(...) {
   l5_ack(l5ms, cookie)
}
l5_cleanup(l5d)


=================

- Registrar-Table:
  Timeouts korrigieren! OK
- Registrar:
  Filterung von Registrar-Transport
  => ASAPTransport
  => PeerPresence
  => Announce
   UDP: nur IP-Header-Sourceadresse
   SCTP: aus Assoc.

- Socket-API:
 * sctp_peeloff(sd, assocID) ohne Addrs.
 * MSG_ -> SCTP_
